<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Ch√≠t M·ªõt</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000 url('snow-bg.jpeg') center center/cover no-repeat fixed;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .guide {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px black;
            background: rgba(0, 0, 0, 0.6);
            display: inline-block;
            padding: 15px 30px;
            border-radius: 15px;
            line-height: 1.8;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 800;
            font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
            display: block;
            margin: 0 auto;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #camera-preview {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 160px;
            height: 120px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            transform: scaleX(-1);
            opacity: 0.8;
            border-radius: 10px;
            background: #000;
        }

        #copyright {
            position: absolute;
            bottom: 5px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            z-index: 100;
            font-family: sans-serif;
            pointer-events: none;
            font-style: italic;
        }

        /* Responsive cho ƒëi·ªán tho·∫°i xoay ngang */
        @media screen and (max-height: 500px) and (orientation: landscape) {
            .guide {
                font-size: 10px;
                padding: 8px 15px;
                margin-bottom: 10px;
                line-height: 1.4;
                max-width: 90%;
                margin-left: auto;
                margin-right: auto;
            }

            #ui-layer {
                bottom: 10px;
            }

            button {
                padding: 10px 30px;
                font-size: 14px;
            }
        }

        /* Responsive cho m√†n h√¨nh nh·ªè */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            .guide {
                font-size: 9px;
                padding: 6px 12px;
                margin-bottom: 8px;
                line-height: 1.3;
            }
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div class="guide">
            ‚ù§Ô∏è <b>2 Tay (Tim):</b> Love<br>
            ‚úä <b>N·∫Øm ƒë·∫•m:</b> Thu c√¢y &nbsp;|&nbsp; üñê <b>X√≤e tay:</b> M·ªü r·ªông &nbsp;|&nbsp; üëå <b>OK:</b> Zoom Photo<br>

                ‚úåÔ∏è‚ûï‚òùÔ∏è <b>3 Ng√≥n:</b> Qu√† &nbsp;|&nbsp; ‚òùÔ∏è <b>1 Ng√≥n:</b> V≈© tr·ª• &nbsp;|&nbsp; ‚úåÔ∏è <b>2 Ng√≥n:</b> S√≠t r·ªãt &nbsp;|&nbsp; ü§ò <b>Rock:</b> Lion
        </div>
        <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <div id="copyright">¬© Khai Hoan</div>

    <div id="selectedPhoto" style="position: absolute; bottom: 100px; width: 100%; text-align: center; color: rgba(255,255,255,0.8); font-size: 18px; font-weight: bold; text-shadow: 0 2px 4px black; display: none;">·∫¢nh 1 ƒë∆∞·ª£c ch·ªçn</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL);
        bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        const photoFiles = [
            './image1.jpg',
            './image2.jpg',
            './image3.jpg',
            './image4.jpg',
            './image5.jpg',
        ];
        const photoTextures = [];
        photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const cx = 32, cy = 32;

            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
            if (type === 'gold_glow') {
                grd.addColorStop(0, '#FFFFFF'); grd.addColorStop(0.4, '#FFD700'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            } else if (type === 'red_light') {
                grd.addColorStop(0, '#FFAAAA'); grd.addColorStop(0.4, '#FF0000'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            } else if (type === 'gift') {
                grd.addColorStop(0, '#AAFFAA'); grd.addColorStop(0.4, '#00FF00'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            }
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift')
        };

        function createSnowTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grd.addColorStop(0, 'rgba(220,240,255,1)');
            grd.addColorStop(0.75, 'rgba(200,230,255,0.6)');
            grd.addColorStop(1, 'rgba(290,255,255,0)');
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 64);
            const t = new THREE.CanvasTexture(cvs); t.needsUpdate = true; return t;
        }
        textures.snow = createSnowTexture();

        const CONFIG = {
            goldCount: 2200,
            redCount: 400,
            giftCount: 200,
            treeHeight: 70,
            treeBaseRadius: 35,
            snowCount: 900
        };

        const HAND_SENSITIVITY = 12.0;
        const HAND_LERP = 0.1;

        let scene, camera, renderer;
        let groupGold, groupRed, groupGift;
        let photoMeshes = [];
        let frameMeshes = [];
        let titleMesh, starMesh, loveMesh, cntt7Mesh;
        let snowSystem;

        let state = 'TREE';
        let selectedIndex = 0;
        let handX = 0.5;

        function getANHYEUEMPoint() {
            const char = Math.floor(Math.random() * 8);
            let x = 0, y = 0, z = 0;
            const t = Math.random();
            switch (char) {
                case 0:
                    if (t < 0.4) { x = -75 + t / 0.4 * 5; y = -10 + t / 0.4 * 20; }
                    else if (t < 0.8) { x = -70 + (t - 0.4) / 0.4 * 5; y = 10 - (t - 0.4) / 0.4 * 20; }
                    else { x = -72.5 + (t - 0.8) / 0.2 * 5; y = 0; }
                    break;
                case 1:
                    if (t < 0.33) { x = -55; y = -10 + (t / 0.33) * 20; }
                    else if (t < 0.66) { x = -55 + ((t - 0.33) / 0.33) * 10; y = 10 - ((t - 0.33) / 0.33) * 20; }
                    else { x = -45; y = -10 + ((t - 0.66) / 0.34) * 20; }
                    break;
                case 2:
                    if (t < 0.33) { x = -35; y = 10 - (t / 0.33) * 20; }
                    else if (t < 0.66) { x = -25; y = 10 - ((t - 0.33) / 0.33) * 20; }
                    else { x = -35 + ((t - 0.66) / 0.34) * 10; y = 0; }
                    break;
                case 3:
                    if (t < 0.33) { x = -15 + (t / 0.33) * 5; y = 10 - (t / 0.33) * 10; }
                    else if (t < 0.66) { x = -5 - ((t - 0.33) / 0.33) * 5; y = 10 - ((t - 0.33) / 0.33) * 10; }
                    else { x = -10; y = ((t - 0.66) / 0.34) * -10; }
                    break;
                case 4:
                    if (t < 0.3) { x = 5; y = 10 - (t / 0.3) * 20; }
                    else if (t < 0.55) { x = 5 + ((t - 0.3) / 0.25) * 10; y = 10; }
                    else if (t < 0.8) { x = 5 + ((t - 0.55) / 0.25) * 8; y = 0; }
                    else { x = 5 + ((t - 0.8) / 0.2) * 10; y = -10; }
                    break;
                case 5:
                    if (t < 0.33) { x = 25; y = 10 - (t / 0.33) * 20; }
                    else if (t < 0.66) { x = 25 + ((t - 0.33) / 0.33) * 10; y = -10; }
                    else { x = 35; y = -10 + ((t - 0.66) / 0.34) * 20; }
                    break;
                case 6:
                    if (t < 0.3) { x = 45; y = 10 - (t / 0.3) * 20; }
                    else if (t < 0.55) { x = 45 + ((t - 0.3) / 0.25) * 10; y = 10; }
                    else if (t < 0.8) { x = 45 + ((t - 0.55) / 0.25) * 8; y = 0; }
                    else { x = 45 + ((t - 0.8) / 0.2) * 10; y = -10; }
                    break;
                case 7:
                    if (t < 0.25) { x = 65; y = -10 + (t / 0.25) * 20; }
                    else if (t < 0.5) { x = 65 + ((t - 0.25) / 0.25) * 5; y = 10 - ((t - 0.25) / 0.25) * 10; }
                    else if (t < 0.75) { x = 70 + ((t - 0.5) / 0.25) * 5; y = ((t - 0.5) / 0.25) * 10; }
                    else { x = 75; y = 10 - ((t - 0.75) / 0.25) * 20; }
                    break;
            }
            x *= 1.0;
            x *= 1.25;
            y *= 1.25;
            return { x, y, z: (Math.random() - 0.5) * 2 };
        }

        function getLionPoint() {
            const r = Math.random();
            let x, y, z;
            if (r < 0.6) {
                const ang = Math.random() * Math.PI * 2;
                const rad = 20 + Math.random() * 15;
                x = Math.cos(ang) * rad; y = Math.sin(ang) * rad; z = (Math.random() - 0.5) * 10;
            } else if (r < 0.9) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const rad = 18 * Math.pow(Math.random(), 0.3);
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta);
                z = rad * Math.cos(phi) + 5;
            } else {
                if (Math.random() > 0.5) { x = (Math.random() > 0.5 ? 8 : -8) + (Math.random() - 0.5) * 2; y = 5; z = 20; }
                else { x = 0; y = -5; z = 22; }
            }
            return { x, y, z };
        }

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.5);
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);

            createPhotos();
            createDecorations();
            createSnow();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pTree = [], pHeart = [], pExplode = [], pGift = [], pUniverse = [], pCNTT7 = [], pLion = [];
            const sizes = [], phases = [];

            for (let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight;
                const r = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius * ((type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1);
                const theta = Math.random() * Math.PI * 2;
                pTree.push(r * Math.cos(theta), h - CONFIG.treeHeight / 2, r * Math.sin(theta));

                const tH = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(tH), 3), hy = 13 * Math.cos(tH) - 5 * Math.cos(2 * tH) - 2 * Math.cos(3 * tH) - Math.cos(4 * tH);
                const rFill = Math.pow(Math.random(), 0.3);
                pHeart.push(hx * rFill * 2.2, hy * rFill * 2.2 + 5, (Math.random() - 0.5) * 10);

                const phi = Math.acos(2 * Math.random() - 1), lam = Math.random() * Math.PI * 2;
                const rad = 65 * Math.cbrt(Math.random());
                pExplode.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));

                const side = 40, axis = Math.floor(Math.random() * 3);
                let gx = (Math.random() - 0.5) * side, gy = (Math.random() - 0.5) * side, gz = (Math.random() - 0.5) * side;
                if (axis === 0) gx = (Math.random() > 0.5 ? 1 : -1) * side / 2; else if (axis === 1) gy = (Math.random() > 0.5 ? 1 : -1) * side / 2; else gz = (Math.random() > 0.5 ? 1 : -1) * side / 2;
                pGift.push(gx * (0.9 + Math.random() * 0.2), gy * (0.9 + Math.random() * 0.2), gz * (0.9 + Math.random() * 0.2));

                const arm = i % 3, spin = Math.random() * 3 * Math.PI, dist = spin * 5;
                pUniverse.push(Math.cos(spin + (Math.PI * 2 / 3) * arm) * dist, (Math.random() - 0.5) * (100 - dist) / 5, Math.sin(spin + (Math.PI * 2 / 3) * arm) * dist);

                const ptC = getANHYEUEMPoint(), ptL = getLionPoint();
                pCNTT7.push(ptC.x, ptC.y, ptC.z); pLion.push(ptL.x, ptL.y, ptL.z);

                pPositions.push(pTree[i * 3], pTree[i * 3 + 1], pTree[i * 3 + 2]);
                sizes.push(size); phases.push(Math.random() * Math.PI * 2);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color(type === 'gold' ? 0xFFD700 : (type === 'red' ? 0xFF0000 : 0xFFFFFF));
            for (let i = 0; i < count; i++) { colors[i * 3] = baseColor.r; colors[i * 3 + 1] = baseColor.g; colors[i * 3 + 2] = baseColor.b; }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            geo.userData = {
                tree: pTree, heart: pHeart, explode: pExplode, gift: pGift, universe: pUniverse, cntt7: pCNTT7, lion: pLion,
                phases: phases, baseColor: baseColor, baseSize: size
            };

            const mat = new THREE.PointsMaterial({
                size: size, map: textures[type], transparent: true, opacity: 1.0,
                vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
            });
            scene.add(new THREE.Points(geo, mat));
            return scene.children[scene.children.length - 1];
        }

        function createPhotos() {
             const geo = new THREE.PlaneGeometry(8, 8);
            for (let i = 0; i < 5; i++) {
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide }));
                mesh.visible = false; mesh.scale.set(0, 0, 0);
                scene.add(mesh); photoMeshes.push(mesh);

                const frameGeo = new THREE.PlaneGeometry(9, 9);
                const frameMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.visible = false;
                scene.add(frame); frameMeshes.push(frame);
            }
        }

        function createDecorations() {
            function txtTex(t, s, c) {
                const cvs = document.createElement('canvas'); cvs.width = 1024; cvs.height = 256;
                const ctx = cvs.getContext('2d'); ctx.font = `bold italic ${s}px "Times New Roman"`; ctx.fillStyle = c;
                ctx.textAlign = 'center'; ctx.shadowColor = "#FFF"; ctx.shadowBlur = 20; ctx.fillText(t, 512, 150);
                return new THREE.CanvasTexture(cvs);
            }
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: txtTex("MERRY CHRISTMAS", 90, '#FFD700'), transparent: true, blending: THREE.AdditiveBlending }));
            titleMesh.position.set(0, 50, 0); scene.add(titleMesh);

            const starCvs = document.createElement('canvas'); starCvs.width = 128; starCvs.height = 128;
            const sCtx = starCvs.getContext('2d'); sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor = "#FFF"; sCtx.shadowBlur = 20;
            sCtx.beginPath();
            for (let i = 0; i < 5; i++) {
                sCtx.lineTo(64 + Math.cos((18 + i * 72) / 180 * Math.PI) * 50, 64 - Math.sin((18 + i * 72) / 180 * Math.PI) * 50);
                sCtx.lineTo(64 + Math.cos((54 + i * 72) / 180 * Math.PI) * 20, 64 - Math.sin((54 + i * 72) / 180 * Math.PI) * 20);
            }
            sCtx.closePath(); sCtx.fill();
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(starCvs), transparent: true, blending: THREE.AdditiveBlending }));
            starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0); scene.add(starMesh);

            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({ map: txtTex("I Love Youuuuuuu ‚ù§Ô∏è", 100, '#FF69B4'), transparent: true, blending: THREE.AdditiveBlending }));
            loveMesh.position.set(0, -20, 20); loveMesh.visible = false; scene.add(loveMesh);

            cntt7Mesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 12), new THREE.MeshBasicMaterial({ map: txtTex("Tran Thi Ngoc Huyen", 100, '#00FFFF'), transparent: true, blending: THREE.AdditiveBlending }));
            cntt7Mesh.position.set(0, -30, 0); cntt7Mesh.visible = false; scene.add(cntt7Mesh);
        }

        function createSnow() {
            const count = CONFIG.snowCount;
            const positions = new Float32Array(count * 3);
            const speeds = new Float32Array(count);
            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = Math.random() * 220 - 40;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                speeds[i] = 0.3 + Math.random() * 1.2;
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
            const mat = new THREE.PointsMaterial({
                size: 4.0,
                map: textures.snow,
                transparent: true,
                opacity: 0.95,
                depthWrite: false,
                blending: THREE.NormalBlending,
                sizeAttenuation: true
            });
            snowSystem = new THREE.Points(geo, mat);
            snowSystem.frustumCulled = false;
            scene.add(snowSystem);
        }

        function updateParticleGroup(group, targetState, speed, time, handRotY) {
            const attr = group.geometry.attributes;
            const positions = attr.position.array, colors = attr.color.array, sizes = attr.size.array;
            const u = group.geometry.userData;

            let key = 'tree';
            if (targetState === 'HEART') key = 'heart';
            else if (targetState === 'EXPLODE' || targetState === 'PHOTO') key = 'explode';
            else if (targetState === 'GIFT') key = 'gift';
            else if (targetState === 'UNIVERSE') key = 'universe';
            else if (targetState === 'ANHYEUEM') key = 'cntt7';
            else if (targetState === 'LION') key = 'lion';

            let targets = u[key];
            for (let i = 0; i < positions.length; i++) positions[i] += (targets[i] - positions[i]) * speed;
            attr.position.needsUpdate = true;

            if (targetState === 'UNIVERSE') { group.rotation.y -= 0.002; group.rotation.z = Math.sin(time * 0.5) * 0.2; }
            else if (targetState === 'GIFT') { group.rotation.y += 0.01; group.rotation.x = Math.sin(time) * 0.1; }
            else if (targetState === 'TREE') { group.rotation.y += 0.005; group.rotation.x = 0; group.rotation.z = 0; }
            else if (targetState === 'EXPLODE') {
                group.scale.set(1,1,1);
                group.rotation.y = THREE.MathUtils.lerp(group.rotation.y, handRotY, HAND_LERP);
            } else { group.rotation.y *= 0.95; group.rotation.x *= 0.95; group.rotation.z *= 0.95; }

            const count = positions.length / 3;
            for (let i = 0; i < count; i++) {
                let b = 0.8 + 0.4 * Math.sin(time * (key === 'explode' ? 15 : 5) + u.phases[i]);
                if (targetState === 'HEART' || targetState === 'CNTT7') b = 1.0;
                colors[i * 3] = u.baseColor.r * b; colors[i * 3 + 1] = u.baseColor.g * b; colors[i * 3 + 2] = u.baseColor.b * b;
                sizes[i] = u.baseSize;
            }
            attr.color.needsUpdate = true; attr.size.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001, speed = (state === 'ANHYEUEM') ? 0.03 : 0.06;
            const handRotY = (handX - 0.5) * HAND_SENSITIVITY;
            updateParticleGroup(groupGold, state, speed, time, handRotY);
            updateParticleGroup(groupRed, state, speed, time, handRotY);
            updateParticleGroup(groupGift, state, speed, time, handRotY);

            if (state === 'HEART' || state === 'ANHYEUEM') {
                const beat = 1 + 0.1 * Math.sin(time * 6);
                groupGold.scale.setScalar(beat);
                groupRed.scale.setScalar(beat);
                groupGift.scale.setScalar(beat);
                loveMesh.scale.setScalar(beat);
            } else {
                groupGold.scale.setScalar(1);
                groupRed.scale.setScalar(1);
                groupGift.scale.setScalar(1);
                loveMesh.scale.setScalar(1);
            }

            titleMesh.visible = (state === 'TREE'); starMesh.visible = (state === 'TREE');
            loveMesh.visible = (state === 'HEART'); cntt7Mesh.visible = (state === 'ANHYEUEM');

            if (state === 'EXPLODE') {
                frameMeshes.forEach(f => f.visible = false);
                titleMesh.visible = false; starMesh.visible = false; loveMesh.visible = false;
                const baseAngle = groupGold.rotation.y;
                const angleStep = (Math.PI * 2) / 5;
                let bestIdx = 0; let maxZ = -999;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = baseAngle + i * angleStep;
                    const x = Math.sin(angle) * CONFIG.treeBaseRadius * 0.85;
                    const z = Math.cos(angle) * CONFIG.treeBaseRadius * 0.85;
                    const y = Math.sin(time + i) * 3;
                    mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
                    mesh.lookAt(camera.position);
                    frameMeshes[i].position.copy(mesh.position);
                    frameMeshes[i].rotation.copy(mesh.rotation);
                    frameMeshes[i].lookAt(camera.position);
                    if (z > maxZ) { maxZ = z; bestIdx = i; }
                    if (z > 5) {
                        const ds = 1.0 + (z/(CONFIG.treeBaseRadius*0.85))*0.8;
                        mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
                    }
                });
                selectedIndex = bestIdx;
                frameMeshes.forEach((f, i) => f.visible = (i === bestIdx));

            } else if (state === 'PHOTO') {
                photoMeshes.forEach((mesh, i) => {
                    mesh.rotation.set(0, 0, 0);
                    mesh.visible = true;
                    if (i === selectedIndex) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1); mesh.scale.lerp(new THREE.Vector3(6, 6, 6), 0.1);
                    } else mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                });
            } else photoMeshes.forEach(m => { m.visible = false; m.scale.set(0, 0, 0); });
            frameMeshes.forEach(f => f.visible = false);

            if (snowSystem) {
                const pos = snowSystem.geometry.attributes.position.array;
                const spd = snowSystem.geometry.attributes.speed.array;
                const count = pos.length / 3;
                const wind = Math.sin(time * 0.35) * 0.6;
                for (let i = 0; i < count; i++) {
                    const ix = i * 3, iy = ix + 1, iz = ix + 2;
                    pos[iy] -= spd[i] * (0.6 + Math.sin(time * 0.5 + i) * 0.2);
                    pos[ix] += wind * (0.4 + Math.sin(i) * 0.1);
                    pos[iz] += Math.cos(time * 0.2 + i) * 0.01;
                    if (pos[iy] < -80) {
                        pos[iy] = 160 + Math.random() * 60;
                        pos[ix] = (Math.random() - 0.5) * 400;
                        pos[iz] = (Math.random() - 0.5) * 400;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y += 0.0006;
            }

            renderer.render(scene, camera);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');

            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

            hands.onResults(results => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                if (results.multiHandLandmarks.length === 0) { state = 'TREE'; return; }

                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0], h2 = results.multiHandLandmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.15 && distThumb < 0.15) { state = 'HEART'; return; }
                }

                const lm = results.multiHandLandmarks[0];
                handX = lm[9].x;

                const isExt = (tip, pip) => lm[tip].y < lm[pip].y;

                const idx = isExt(8, 6), mid = isExt(12, 10), ring = isExt(16, 14), pinky = isExt(20, 18);

                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if (pinchDist < 0.05) {
                    state = 'PHOTO';
                    return;
                }

                if (!idx && !mid && !ring && !pinky) { state = 'TREE'; return; }

                if (idx && mid && ring && pinky) { state = 'EXPLODE'; return; }

                if (idx && !mid && !ring && !pinky) { state = 'UNIVERSE'; return; }

                if (idx && mid && !ring && !pinky) { state = 'ANHYEUEM'; return; }

                if (idx && !mid && !ring && pinky) { state = 'LION'; return; }

                if (idx && mid && ring && !pinky) { state = 'GIFT'; return; }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({ image: video }); }, width: 320, height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if (camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        });
    </script>
</body>